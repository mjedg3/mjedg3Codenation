//FILE GENERATED BY 'generate-resources-js.sh'!
};
/**
 * Handler for SafariExtensionHandler obj-c communication.
 * Nothing in this injeted script is persistent or able to access
 * external services outside the websites security settings.
 * SafariExtensionHandler is required for such things.
 */
class MessageHandler {
    constructor(configure)
    {
        this.http_proxy_request_map = new Map();
        this.config_update_queue = [];

        const handle_config_update = (config) => {
            if (configure(config)) {
                this.config_update_queue.forEach((request) => {
                    request();
                });

                this.config_update_queue = [];
            }
        };

        safari.self.addEventListener('message', (event) => {
            if (event.name === 'fs-config') {
                handle_config_update(event.message);
            } else if (event.name === 'fs-http-proxy') {
                if (this.http_proxy_request_map.size !== 0) {
                    const request = this.http_proxy_request_map.get(event.message.url);
                    if (request) {
                        request(event.message.response);
                        this.http_proxy_request_map.delete(event.message.url);
                    } else {
                        console.trace('key not found in map', event.message.url, this.http_proxy_request_map);
                    }
                }
            } else {
                console.error('unknown event', event.name);
            }
        });
    }

    update_configuration(callback)
    {
        if (callback) {
            this.config_update_queue.push(callback);
        }

        safari.extension.dispatchMessage('fs-config');
    }

    proxy_request(url, method, body, callback)
    {
        this.http_proxy_request_map.set(url, callback);
        safari.extension.dispatchMessage('fs-http-proxy', {
            url,
            method,
            body: body ? body : null,
        });
    }

    static whitelist_url(url, cookie)
    {
        console.debug('whitelisting url', url, 'with cookie', cookie);
        if (url && cookie) {
            safari.extension.dispatchMessage('fs-blockpage-button-action', {
                url,
                cookie,
            });
        } else {
            console.error('url or cookie missing');
        }
    }

    static log(level, log)
    {
        //note, log forwarding to safari objective-c through IPC dispatchMessage is extremely CPU intensive and can hang Safari on busy websites
        safari.extension.dispatchMessage('fs-log', {
            level,
            log,
        });
    }
}
const search_engine = {
    resolve(url) {
        if (search_engine.current) {
            return search_engine.current;
        }

        search_engine.current = null;

        if (search_engine.engines) {
            for (const [name, engine] of Object.entries(search_engine.engines)) {
                if (engine.regex.test(url)) {
                    search_engine[name] = engine;
                    search_engine.current = engine;
                    break;
                }
            }

            search_engine.engines = null;
        }

        return search_engine.current;
    },
    parse_redirection(url) {
        if (!search_engine.yahoo) {
            return null;
        } else if (url.match(search_engine.yahoo.alt_redirection_regex)) {
            url = 'http:' + url;
        } else if (!url.match(search_engine.yahoo.redirection_regex)) {
            return null;
        }

        const link_query_params = url.replace(search_engine.yahoo.path_regex, '').split('/');
        const query_params = {};
        let redirection_url = null;

        link_query_params.forEach((pairstr) => {
            const keyvalue = pairstr.split('=');
            keyvalue[0] = unescape(keyvalue[0]);
            if (keyvalue.length > 1) {
                keyvalue[1] = unescape(keyvalue[1]);
            }
            query_params[keyvalue[0]] = keyvalue[1];
        });

        if (query_params.RU) {
            redirection_url = query_params.RU;
        }

        console.trace('Parsed Yahoo redirection parameters ', query_params, ' with redirect to ', redirection_url);
        return redirection_url;
    },
    engines: {
        google: {
            regex: /^https*:\/\/www\.google\.[^/].*/,
            operate(callback) {
                callback(document.querySelectorAll('div.rc .r a:not(.fl)'));
                callback(document.querySelectorAll('div span h3.r a')); //subcategories
            },
            search_path_regex: /^(?:search|images|custom|cse|s)$/,
            safe_search_query: 'safe=vss',
        },
        bing: {
            regex: /^https*:\/\/www\.bing\.com.*/,
            operate(callback) {
                callback(document.querySelectorAll('#b_results li.b_algo h2 a'));
                callback(document.querySelectorAll('#b_results li.b_algo div ul li h3 a')); //subcategories
            },
            search_path_regex: /^(?:search|images|videos)$/,
            safe_search_query: 'adlt=strict',
        },
        yahoo: {
            regex: /^https*:\/\/.*\.yahoo\.com.*/,
            redirection_regex: /^https*:\/\/r\.search\.yahoo\.com.*/,
            alt_redirection_regex: /^\/\/r\.search\.yahoo\.com.*/,
            path_regex: /^https*:\/\/[^/]+\//,
            operate(callback) {
                callback(document.querySelectorAll('#web ol li div div h3 a'));
            },
            search_path_regex: /^search$/,
            safe_search_query: 'vm=r',
        },
        yahoo_jp: {
            regex: /^https*:\/\/.*\.yahoo\.co\.jp.*/,
            operate(callback) {
                callback(document.querySelectorAll('div.hd h3 a'));
            },
            search_path_regex: /^search$/,
            safe_search_query: 'vm=r',
        },
        duckduckgo: {
            regex: /^https*:\/\/duckduckgo\.com.*/,
            operate(callback) {
                function try_find() {
                    callback(document.querySelectorAll('#links div div h2 a:not(.result__check)'));
                }

                try_find();

                search_engine.mutation_observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        console.debug('mutation observer event', mutation);
                    });

                    try_find();
                });

                try {
                    search_engine.mutation_observer.observe(document.querySelector('div#links.results'), {
                        childList: true,
                    });
                } catch (error) {
                    console.debug(error);
                }
            },
            search_path_regex: '',
            safe_search_query: 'kp=1',
        },
    },
};
function hostname_for_url(url) {
    url = new URL(url);
    console.debug('hostname_for_url ' + url + ' is ' + url.hostname);
    return url.hostname;
}

function is_whitelisted_in(url, fsbp_whitelist) {
    if (!url) {
        return false;
    }

    console.debug('is_whitelisted: checking url ' + url);
    for (const i in fsbp_whitelist) {
        if (fsbp_whitelist[i] === url) {
            console.log('Whitelisted URL (exact match)');
            return true;
        }
        if (fsbp_whitelist[i].indexOf('://') > -1) {
            // full URL in whitelist
            console.debug('Comparing whitelisted URL ' + fsbp_whitelist[i] + ' against base of ' + url);
            const fs_baseURL_re = /([^:]+:\/\/[^/]+).*/;
            const baseURL_whitelist = fsbp_whitelist[i].replace(fs_baseURL_re, '$1');
            const baseURL_queried = url.replace(fs_baseURL_re, '$1');
            if (baseURL_whitelist === baseURL_queried) {
                console.log('Whitelisted URL (base URL match)', url, fsbp_whitelist[i]);
                return true;
            }
        } else {
            // domain in whitelist
            console.debug('Comparing whitelisted domain ' + fsbp_whitelist[i] + ' against ' + hostname_for_url(url));
            const host_name = hostname_for_url(url);
            if (host_name === fsbp_whitelist[i]) {
                console.log('Exact whitelist match');
                return true;
            }
            const parts = host_name.split('.').reverse();
            let str = '';
            for (let part_index = 0; part_index < parts.length; part_index++) {
                if (str === '') {
                    str = parts[part_index];
                } else {
                    str = parts[part_index] + '.' + str;
                }

                console.debug('Comparing ' + str + ' with ' + fsbp_whitelist[i] + ' (part_index=' + part_index + ')');
                if (str === fsbp_whitelist[i]) {
                    console.debug('Reverse domain match (' + str + '=' + fsbp_whitelist[i] + ')');
                    return true;
                }
            }
        }
    }

    return false;
}
/**
 * Return true if an object with the supplied cats should be blocked
 * according to current settings. To block a category, add it to global array
 * "blocked_cats" (e.g. blocked_cats = ["adserving", "fso_adserving"];
 */
function is_unsafe(cats) {
    const unsafe = cats && cats.safe && cats.safe[0] < -79;
    console.debug(`${arguments.callee.name}: ${unsafe}`);
    return unsafe;
}

function banking_protection_enabled() {
    const enabled = fsbpconfig['fsbankp-disabled'] !== '1';
    console.debug(`${arguments.callee.name}: ${enabled}`);
    return enabled;
}

function content_blocking_enabled() {
    if (fsbpconfig['fsbp-content-block'] && fsbpconfig['fsbp-content-block'].disabled === '1') {
        return false;
    }

    return true;
}

function content_category_states() {
    return fsbpconfig['fsbp-content-block'] ? fsbpconfig['fsbp-content-block']['category-enabled-states'] : {};
}

function blocked_categories() {
    const cats = [];
    const states = content_category_states();
    for (const key in states) {
        if (states[key] === true) {
            cats.push(key);
        }
    }

    return cats;
}

function blocked_category_set(cats) {
    const cats_intersection = [];

    if (content_blocking_enabled()) {
        const blocked_cats = blocked_categories();
        for (const i in blocked_cats) {
            const cat = blocked_cats[i];
            if (cat in cats) {
                if (cats[cat][0] > 80) {
                    cats_intersection.push(cat);
                }
            } else if (cat === 'unknown') {
                if (!cats || (cats.safe && cats.safe[0] === 0)) {
                    cats_intersection.push('unknown');
                }
            }
        }
    }

    return cats_intersection;
}

function is_banking_site(cats) {
    if (!banking_protection_enabled()) {
        return false;
    }

    if (cats.fso_safe && cats.fso_safe[0] >= 80) {
        if (cats.fso_dynamic && cats.fso_dynamic[0] === 100) {
            console.log('Not a banking site');
            return false;
        }

        if (cats.fso_banking && cats.fso_banking[0] >= 80) {
            console.log('This is banking site');
            return true;
        }

        console.log('safe, not dynamic, fso_banking < 80, not banking site');
        return false;
    }

    console.log('not a safe site for banking');
    return false;
}

function is_whitelisted(url) {
    return fsbpconfig.whitelist ? is_whitelisted_in(url, fsbpconfig.whitelist) : false;
}

function is_url_an_attachment_content(url) {
    let is_attached_content = false;
    try {
        const req = new XMLHttpRequest();
        req.open('HEAD', url, false);
        req.send(null);
        const contenttype = req.getResponseHeader('content-type');
        const is_attachment = req.getResponseHeader('content-disposition');
        console.debug('Content type: ', contenttype, 'Content disposition: ', is_attachment);

        if ((contenttype && (contenttype.toLowerCase().indexOf('application') !== -1)) ||
        (is_attachment && (is_attachment.toLowerCase().indexOf('attachment') !== -1))) {
            console.log('content type matched to attached stream');
            is_attached_content = true;
        }
    } catch (error) {
        is_attached_content = false;
        console.error('Exception occurred while loading the url using XMLHttpRequest', error);
    } finally {
        console.log('is_url_an_attachment_content', is_attached_content);
    }

    return is_attached_content;
}

function domain_name_for_the_url(url) {
    let domain;
    const host_name = hostname_for_url(url);
    if (host_name) {
        const parts = host_name.split('.').reverse();
        if (parts && parts.length > 1) {
            domain = parts[1] + '.' + parts[0];
            if (((host_name.toLowerCase().indexOf('.co.uk') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.au') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.tw') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.tr') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.nz') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.vn') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.my') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.hsk') !== -1) ||
            (host_name.toLowerCase().indexOf('.com.br') !== -1) ||
            (host_name.toLowerCase().indexOf('.or.jp') !== -1)) && parts.length > 2) {
                domain = parts[2] + '.' + domain;
            }
        }
    }

    console.debug('Domain name (from local) is ', domain);
    return domain;
}
function ready(fn) {
    if (document.attachEvent ? document.readyState === 'complete' : document.readyState !== 'loading') {
        fn();
    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}

function get_language() {
    const locale = window.navigator.language.split('-');
    return locale.length > 1 ? locale[1] : locale[0];
}

function get_popup_bubble() {
    let popup_x_offset = '-32px';
    if (search_engine.bing) {
        popup_x_offset = '-13px';
    }

    return 'background-image:url(' + fs_rating_images.bubble_background + ');width:410px;display: block !important; opacity:0.9; position: absolute; z-index: 50; top: -65px; left: ' + popup_x_offset + ';';
}

let current_popup = null;

function add_rating_actions(bubbleInfo) {
    const rating_image = bubbleInfo.firstChild;
    const bubble = rating_image.nextSibling;

    function hide(popup) {
        if (popup) {
            popup.style = 'display: none; opacity:0;';
        }
    }

    function schedule_hide(popup) {
        popup.hideTimeoutId = setTimeout(() => {
            hide(popup);
        }, 500);
    }

    if (rating_image.className === 'rating-summary-rating-icon fs-bp-status' &&
    bubble.className === 'fsc-bp-popup outer-bubble') {
        bubble.addEventListener('mouseenter', () => {
            if (bubble.hideTimeoutId) {
                clearTimeout(bubble.hideTimeoutId);
            }
        });

        bubble.addEventListener('mouseleave', () => {
            schedule_hide(bubble);
        });

        bubble.addEventListener('click', (event) => {
            console.debug('bubble clicked');
            event.stopPropagation();
            hide(bubble);
        });

        rating_image.addEventListener('mouseleave', () => {
            schedule_hide(bubble);
        });

        rating_image.addEventListener('click', (event) => {
            console.debug('rating image clicked');
            event.stopPropagation();
            hide(current_popup);
            bubble.style = get_popup_bubble();
            current_popup = bubble;
        });
    }
}

function add_blockpage_categories(blocked_categories) {
    if (!fsbpconfig) {
        console.error('cannot fill blocked category names/images to blockpage without fsbpconfig');
        return '';
    }

    let tags = '';
    for (let i = 0; i < blocked_categories.length; i++) {
        const category = fs_category_mappings[blocked_categories[i]];
        if (!category) {
            console.error('category name not found in fs_category_mappings: ', blocked_categories[i]);
        } else {
            tags += '<img src=\'' + category.icon + '\' style=\'vertical-align: middle;\'><span style=\'vertical-align: middle;\'>' + fsbpconfig[category.title] + '</span>';
        }
    }

    if (tags !== '') {
        return '<div><div>' + tags + '</div></div>';
    }

    return '';
}

function add_rating_container_categories(blocked_categories) {
    if (!fsbpconfig) {
        console.error('cannot fill blocked category names/images to rating container without fsbpconfig');
        return '';
    }

    let tags = '';
    for (let i = 0; i < blocked_categories.length; i++) {
        const category = fs_category_mappings[blocked_categories[i]];
        if (!category) {
            console.error('category name not found in fs_category_mappings: ', blocked_categories[i]);
        } else {
            tags += '<img src=\'' + category.icon + '\'><span style=\'font-size:12px;\'>' + fsbpconfig[category.title] + '</span>';
        }
    }

    if (tags !== '') {
        return '<div class=\'category-container\' style=\'margin-top: 17px  !important; margin-left: 36px\'>' +
        '<div class=\'line2\' style=\'display:block;font-size:11px;\'>' +
        tags +
        '</div></div>';
    }

    return '';
}

function create_rating_icon(icon, class_name) {
    const imgalign = search_engine.bing ? 'bottom' : 'left';
    let imgstyle = 'position:relative; top: 50%; height: 16px;';

    if (search_engine.duckduckgo) {
        if (is_safari()) {
            imgstyle += 'top: 1px;';
        } else {
            imgstyle += 'top: 3px;';
        }
    } else if (!is_safari() && (search_engine.bing || search_engine.yahoo)) {
        imgstyle += 'top: 2px;';
    } else if (search_engine.yahoo_jp) {
        imgstyle += 'top: 4px;';
    } else if (search_engine.google) {
        if (is_safari()) {
            imgstyle += 'top: 2px;';
        } else {
            imgstyle += 'top: 3px;';
        }

        if (get_language() === 'jp') {
            imgstyle += '-webkit-transform: translateY(25%);';
        }
    }

    return '<img src="' + icon + '" class="' + class_name + '" align="' + imgalign + '" style="' + imgstyle + '">';
}

function create_rating_bubble(icon, localized_text, category_info) {
    const line_margin_top_offset = category_info !== '' ? '3px' : '10px';
    let line1_style_top_margin = 'margin-top: ' + line_margin_top_offset + '  !important';
    line1_style_top_margin = 'top: ' + line_margin_top_offset + '  !important';

    return '<div class="fsc-bp-popup outer-bubble" style="display: none; opacity:0;">' +
    '<div class="inner-bubble" style="margin-top:0px;">' +
    '<div class="status-container" style="height:32px;zoom:1;display:block;position:absolute;">' +
    '<img class="status-image" src="' + icon + '">' +
    '</div>' +
    '<div class="line-container" style="' + line1_style_top_margin + '; width:345px;">' +
    '<div class="line1" style="width:345px; font-weight: bold;">' +
    localized_text +
    '</div>' +
    '</div>' +
    category_info +
    '</div>';
}

function create_rating_container(icon, localized_text, category_info) {
    return '<span class="bubbleInfo">' +
    create_rating_icon(icon, 'rating-summary-rating-icon fs-bp-status') +
    create_rating_bubble(icon, localized_text, category_info) +
    '</span>';
}

function get_rating_icon(cats, is_whitelisted, is_blocked, fsbpconfig) {
    let icon = fs_rating_images.unknown;
    let localization_key = 'string-unknown';

    if (is_whitelisted) {
        icon = fs_rating_images.blue;
        localization_key = 'string-whitelisted';
    } else if (is_blocked) {
        icon = fs_rating_images.denied;
        localization_key = 'string-denied';
    } else if (cats.safe) {
        if (cats.safe[0] < -79) {
            icon = fs_rating_images.error;
            localization_key = 'string-malicious';
        } else if (cats.safe[0] >= 80) {
            icon = fs_rating_images.ok;
            localization_key = 'string-safe';
        } else if (cats.safe[0] > -20) {

        } else if (cats.safe[0] > -80) {
            icon = fs_rating_images.warning;
            localization_key = 'string-suspicious';
        } else if (cats.error) {
            localization_key = 'string-error';
        } else {
            localization_key = 'string-error';
        }
    }

    return {
        icon,
        localization: fsbpconfig[localization_key],
    };
}

function do_inject_rating_icon(node, cats, is_whitelisted, blocked_cats) {
    const rating = get_rating_icon(cats, is_whitelisted, blocked_cats.length, fsbpconfig);
    const rating_container = create_rating_container(rating.icon, rating.localization, add_rating_container_categories(blocked_cats));

    if (search_engine.google ||
    search_engine.yahoo_jp ||
    search_engine.duckduckgo) {
        // prevent bubble cropping
        node.parentNode.style = 'overflow: visible;';
    }

    node.insertAdjacentHTML('beforebegin', rating_container);
    add_rating_actions(node.previousSibling);
}

function fix_bubble_cropping() {
    function overflow_style(selector, override) {
        override = override || 'overflow: visible';
        document.querySelectorAll(selector).forEach((node) => {
            node.style = override;
        });
    }

    if (search_engine.yahoo) {
        overflow_style('div#sticky-hd', 'z-index: 3');
        overflow_style('div#web');
        overflow_style('div#cols');
        overflow_style('div#results');
        overflow_style('ol.reg.mb-15.searchCenterMiddle');
        overflow_style('div.compTitle');
        overflow_style('ol.reg.searchCenterMiddle');
    } else if (search_engine.yahoo_jp) {
        overflow_style('div.w');
    }
}

function apply_search_results(search_engine) {
    if (search_engine) {
        ready(() => {
            console.log('starting checks for ratings');
            search_engine.operate(update_link);
        });
    }
}

function update_link(nodeList) {
    console.debug(nodeList);

    if (!search_engine.resolve(document.URL)) {
        console.debug('Page is not a search engine, not doing link checks for' + document.URL);
        return;
    }
    if (!fsbpconfig.ctx && fsbpconfig['orsp-status'] !== 'orsp-status-503') {
        console.error('No ORSP context, no point in checking links');
        return;
    }

    console.log('Checking links for', document.URL);

    fix_bubble_cropping();

    nodeList.forEach((node, index) => {
        check_reputation(node, index);
    });
}

function check_reputation(node, index) {
    console.debug(node);
    if (node.previousSibling && node.previousSibling.className === 'bubbleInfo') {
        return; //already injected
    }

    const url = get_href(node);
    if (!url) {
        console.debug('no url for reputation check in', node, 'it is not a search link');
        return;
    }

    node.insertAdjacentHTML('beforebegin', create_rating_icon(fs_rating_images.waiting, 'rating-summary-rating-icon fs-bp-status fs-bp-wait-rotate fs-bp-wait-spinner-' + index));

    console.debug('starting reputation check for', url);
    check_url_for_node(node, url, (cats) => {
        if (!cats || cats.error) {
            console.error('ORSP lookup error');
            return false;
        }

        const spinner = document.querySelector('.fs-bp-wait-spinner-' + index);
        spinner.parentNode.removeChild(spinner);

        inject_rating_icon(node, cats, url);
        return true;
    });
}

function get_href(node) {
    const url = node.getAttribute('href');
    if (!url || url.length < 3) {
        return null;
    }

    return url;
}

function format_blockpage(info, whitelist_url_handler) {
    if (info && document.querySelector('#url')) {
        console.debug('formatting blockpage with', info);
        document.querySelector('#url').textContent = info.url;
        document.querySelector('#fsbpport').textContent = info.fsbpport;
        document.querySelector('#fsbpcookie').textContent = info.fsbpcookie;
        document.querySelector('#ctype').textContent = info.ctype;

        if (info.cats) {
            document.querySelector('#cats').textContent = JSON.stringify(info.cats);
        }

        const categories = document.querySelector('#categories');
        if (categories && info.categories) {
            categories.innerHTML += add_blockpage_categories(info.categories);
        }

        const whitelist_button = document.getElementById('button-two');
        if (whitelist_button) {
            whitelist_button.addEventListener('click', () => {
                console.debug('right button action clicked');
                const action = document.getElementById('rightActionValue').value;
                const blockedURL = document.getElementById('url').firstChild.nodeValue;
                if (action === 'action_id=whitelist' && blockedURL !== '') {
                    const fs_baseURL_re = /([^:]+:\/\/[^/]+).*/;
                    const url = blockedURL.replace(fs_baseURL_re, '$1');
                    const cookie = document.getElementById('fsbpcookie').innerHTML;
                    whitelist_url_handler(url, cookie);
                } else {
                    console.error('rightActionValue or blocked url not found!');
                }
            }, true);
        }
    } else {
        console.error('format_blockpage error');
    }
}
let fsbpconfig = null;

function is_safari() {
    return true;
}

function check_url_for_node(node, url, callback) {
    check_url(url, callback);
}

function inject_rating_icon(node, cats, url) {
    do_inject_rating_icon(node, cats, is_whitelisted(url), blocked_category_set(cats));
}

function check_url(url, callback) {
    const starttime = new Date().getTime();

    if (!callback) {
        console.error('No callback');
        return;
    }

    if (!url) {
        console.error('Skipping ORSP lookup for undefined url');
        callback();
        return;
    }

    if (!fsbpconfig.ctx) {
        console.error('orsp context id not configured');
        callback();
        return;
    }

    url = url.replace(/\/$/, ''); //safari inserts a trailing slash to urls
    url = search_engine.parse_redirection(url) || url;

    if (!url.match(/^https?:/i)) {
        console.debug('ignoring non https protocol', url);
        callback();
        return;
    }

    if (url.match(/^https?:\/\/127\.0\.0\.1:*[0-9]*\//i) || url.match(/^https?:\/\/localhost:*[0-9]*\//i)) {
        console.debug('ignoring Localhost URL', url);
        callback();
        return;
    }

    console.debug('check_url', url);
    const space_re = new RegExp('\\+', 'g');
    const orsp_timeout = 4500;
    var escaped_url = escape(url);
    const orsp_req_url = 'http://127.0.0.1:' + fsbpconfig.orspport + '/query/nrs/' + fsbpconfig.ctx + '?t=' + orsp_timeout + '&u=' + escaped_url.replace(space_re, '%2b');

    json_request(orsp_req_url, {
        timeout: 5000,
        success(data) {
            console.trace(data);
            const cats = data.cats;
            const result = {};
            cats.forEach((value) => {
                const cat_name = value[0];
                result[cat_name] = value.slice(1);
            });
            const elapsed = new Date().getTime() - starttime;
            console.debug('check_url request succeeded for ' + url + ' after ' + elapsed + ' ms');

            callback(result);
        },
        error(error, status) {
            const elapsed = new Date().getTime() - starttime;
            console.error('check_url request failed');
            console.debug('failed for ' + url + ' after ' + elapsed + ' ms', error, status);

            let result;
            if (status === 'timeout') {
                result = {
                    cats: [],
                    warning: 'orsp_connection_timeout',
                    elapsed_ms: elapsed,
                };
            } else if (error) {
                result = {
                    error,
                };
            }

            callback(result);
        },
    });
}

function json_request(url, options) {
    const method = options.type ? options.type : 'GET';
    console.debug('fs-http-proxy request (' + method + ') ' + url);

    message_handler.proxy_request(url, method, options.body, (response) => {
        console.debug('json_request loaded result "' + response + '"');
        let json;
        try {
            json = JSON.parse(response);
        } catch (error) {
            console.error(error);
            options.error();
            return;
        }

        options.success(json);
    });
}

function generate_blockpage(url, cats, category_block) {
    url = search_engine.parse_redirection(url) || url;

    const query = category_block ? '/cb?' : '/b?';
    const id = Math.floor(Math.random() * 100000000);
    const blockpage = {
        url: 'http://127.0.0.1:' + fsbpconfig.bpport + query + id,
        info: {
            url,
            id,
            cats,
            ctime: new Date().getTime(),
            ctype: is_url_an_attachment_content(url),
            blocked_categories: blocked_category_set(cats),
        },
    };

    return blockpage;
}

function get_blockpage_url(id) {
    let url = 'http://127.0.0.1:' + fsbpconfig.bpport + '/blockpage-info';
    if (id !== undefined) {
        url += '?' + id;
    }

    return url;
}

function show_blockpage(blockpage) {
    console.debug('storing blockpage info: ', blockpage);
    const starttime = new Date().getTime();
    let request_body;

    try {
        request_body = JSON.stringify({
            info: blockpage.info,
        });
    } catch (e) {
        console.error('fatal error, can\'t store blockpage info', e);
        return;
    }

    function redirect() {
        // replaces the location of the current window with the new one, removing history
        window.location.replace(blockpage.url);
    }

    const url = get_blockpage_url();
    json_request(url, {
        type: 'POST',
        body: request_body,
        success() {
            const elapsed = new Date().getTime() - starttime;
            console.debug('store_blockpage POST succeeded for ' + url + ' after ' + elapsed + ' ms');

            redirect();
        },
        error(error, status) {
            const elapsed = new Date().getTime() - starttime;
            console.error('store_blockpage request failed!');
            console.debug('fail for ' + url + ' after ' + elapsed + ' ms', error, status);

            redirect(); // redirect even in the case of errors. it looks good even without formatting and info
        },
    });
}

function get_blockpage_info() {
    const starttime = new Date().getTime();
    console.log('getting blockpage info for ID ' + document.URL.split(/\?/)[1]);

    const url = get_blockpage_url(document.URL.split(/\?/)[1]);
    json_request(url, {
        success(blockpage_info) {
            const elapsed = new Date().getTime() - starttime;
            console.debug('get_blockpage_info succeeded for ' + url + ' after ' + elapsed + ' ms');
            console.trace('get_blockpage_info response', blockpage_info);

            finish_blockpage(blockpage_info);
        },
        error(error, status) {
            const elapsed = new Date().getTime() - starttime;
            console.error('get_blockpage_info request failed');
            console.debug('fail for ' + url + ' after ' + elapsed + ' ms', error, status);
        },
    });
}

function finish_blockpage(blockpage_info) {
    ready(() => {
        format_blockpage({
            url: blockpage_info.url,
            fsbpport: fsbpconfig.bpport,
            fsbpcookie: fsbpconfig.cookie,
            ctype: blockpage_info.ctype,
            categories: blockpage_info.blocked_categories,
        }, MessageHandler.whitelist_url);
    });
}

function browsing_protection_enabled() {
    const enabled = fsbpconfig['fsbp-disabled'] !== '1';
    console.debug(`${arguments.callee.name}: ${enabled}`);
    return enabled;
}

function process_page_content() {
    if (browsing_protection_enabled() || content_blocking_enabled()) {
        const engine = search_engine.resolve(document.URL);
        if (!safe_search_redirect(engine)) {
            resolve_blocking(document.URL);
        }

        if (browsing_protection_enabled()) {
            apply_search_results(engine);
        }
    }
}

function valid_subscription() {
    const invalid = !fsbpconfig.ctx || fsbpconfig['orsp-status'] === 'subscription-invalid';
    console.debug(`${arguments.callee.name}: ${!invalid}`);
    return !invalid;
}

function resolve_subscription() {
    // poll here for valid subscription, then continue
    if (valid_subscription()) {
        process_page_content();
    } else {
        setTimeout(() => {
            message_handler.update_configuration(resolve_subscription);
        }, 3000);
    }
}

function safe_search_redirect(engine) {
    if (engine) {
        const url = new URL(document.URL);
        const pathname = url.pathname.substring(1);
        if (engine.search_path_regex && engine.search_path_regex.test(pathname)) {
            if (document.URL.includes(engine.safe_search_query)) {
                console.log('SafeSearch enabled');
            } else if (content_blocking_enabled()) {
                console.log('redirecting with SafeSearch');
                window.location.replace(document.URL + '&' + engine.safe_search_query);
                return true;
            }
        }
    }

    return false;
}

function resolve_blocking(url) {
    if (is_whitelisted(url)) {
        console.debug('allowing whitelisted page ', url);
        return;
    }

    check_url(url, (cats) => {
        if (!cats || cats.error) {
            console.error('ORSP lookup error');
            return;
        }

        let blockpage = null;

        if (is_banking_site(cats)) {
            trigger_banking_notification(url);
        } else if (is_unsafe(cats)) {
            //always go to blockpage for unsafe sites, no matter what
            blockpage = generate_blockpage(url, cats, false);
        } else if (blocked_category_set(cats).length) {
            //this can only happen if content blocking is enabled
            blockpage = generate_blockpage(url, cats, true);
        }

        if (blockpage && blockpage.url) {
            console.log('redirecting to blockpage:');
            console.debug('blocking [' + url + '] redirecting to: ' + blockpage.url);
            show_blockpage(blockpage);
        } else {
            console.log('page is safe or allowed by content blocking');
        }
    });
}

function trigger_banking_notification(url) {
    const domain = domain_name_for_the_url(url);
    console.log('triggering banking notification');
    console.debug('domain ', domain, 'with cookie ', fsbpconfig.cookie);

    if (!domain || !fsbpconfig.cookie) {
        console.error('url or cookie is missing, notification will not work');
        return;
    }

    const request_body = {
        'banking': {
            'bankurl': domain,
            'cookie': fsbpconfig.cookie,
        },
    };

    const banking_trigger_url = 'http://127.0.0.1:' + fsbpconfig.bpport + '/banking';
    json_request(banking_trigger_url, {
        url,
        type: 'POST',
        body: JSON.stringify(request_body),
        success(data) {
            console.debug('submitted current banking notification details', data);
        },
        error(error) {
            console.error('error submitting banking notification details', error);
        },
    });
}

function set_configuration(message) {
    try {
        fsbpconfig = JSON.parse(message.config);
    } catch (e) {
        console.error('fatal error, config missing. unable to run injection further', e);
        return false;
    }

    fsbpconfig.ctx = message.orspContext;
    fsbpconfig.bpport = message.bpPort;
    fsbpconfig.cookie = message.bpCookie;

    // snuff out all logs for performance reasons. comment out the method to enable logs for development
    console_override(MessageHandler.log, [
    'error',
    'info',
    'log',
    'debug',
    'trace',
    'warn',
    ]);

    //this variant forwards to system NSLog through XPC but it is too CPU intensive to enable in production
    //console_override(MessageHandler.logsearch
    console.log('settings and configuration updated');
    console.debug('fsbpconfig: ', fsbpconfig);
    return true;
}

function process_page() {
    const blockpage_regex = /^http:\/\/127\.0\.0\.1:[0-9]+\/[cb]/;

    if (blockpage_regex.test(document.URL)) {
        get_blockpage_info();
    } else {
        resolve_subscription();
    }
}

function inject() {
    console.log('injection entry point. starting message loop with extension sandbox and waiting for settings...');
    message_handler.update_configuration(process_page);
}

const message_handler = new MessageHandler(set_configuration);

inject();
function console_override(log_forward, method_silencers) {
    if (window.console) {
        const methods = [
        'error',
        'info',
        'log',
        'debug',
        'trace',
        'warn',
        ];

        const override = function(method) {
            return function(...args) {
                console_override_internal(log_forward, method, args);
            };
        };

        const silence = function() {};

        if (!method_silencers) {
            method_silencers = [];
        }

        methods.forEach((method) => {//NOTE! comment out the below line to log into browser internal console.
            window.console[method] = method_silencers.includes(method) ? silence : override(method);
        });
    }
}

function console_override_internal(log_forward, log_level, ...args) {
    let log = '';
    Object.values(args[0]).forEach((value) => {
        if (value.constructor === String) {
            log += value;
        } else {
            try {
                log += JSON.stringify(value);
            } catch (e) {
                log += value;
            }
        }

        log += ' ';
    });

    if (log_forward && log !== '') {
        log_forward(log_level, log);
    }
}

